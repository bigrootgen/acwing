# This file should only be words and no images

* 参考书
1. 《信息学奥赛一本通》
2. 《算法竞赛进阶指南》（李）
3. 《算法导论》
4. 《数据结构》（严）
5. 《挑战程序设计竞赛》

* 技巧 篇
  程序设计常用的三类基本数据：char[] or string, int(作为整数），int(作为bit数组）
** string vs char[]
1. 需要当作参数传递，选择string
2. 按字符复杂操作（一般指棋盘模型），选择char[]
3. 在string和char[]转换，需要实现set和get
4. 是否需要**substr**和**按值传递**
--------------
** string用法

拼接技巧：
取前i个字符：s.substr(0, i);
取后i个字符：s.substr(s.size()-k, k);
简单字符串匹配（复杂度较高）：
#+BEGIN_SRC c
for (int i = 0; i < s.size(); i++) if (s.substr(i, b.size()) == b) break;
#+END_SRC
单词接龙-前后缀匹配：
#+BEGIN_SRC c
  string word[N];
  int g[N][N];
  for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) {
      string a = word[i], b = word[j];
      for (int k = 1; k < min(a.size(), b.size()); k++)
        if (a.substr(a.size() - k, k) == b.substr(0, k)) {
          g[i][j] = k;
          break;
        }
    }
#+END_SRC
set & get
#+BEGIN_SRC c
  char s[];
  void set(string state) {
    int k;
    for (int i = 0; i < n; i++) s[i] = state[k++];
  }

  string get() {
    string res;
    for (int i = 0; i < n; i++) res += s[i];
    return res;
  }
#+END_SRC
---------------
   
** vector vs int[]
   1. vector只能当容器使用，而int[]的使用灵活多样, vector无法存储映射，int[]
   可以存储映射
   2. vector动态分配内存，而int[]需要在使用前分配好空间
   3. 作为集合看待时，vector优于int[]，如果使用int[]需要额外维护指针
   如果经常查询两个元素是否在同一集合，考虑使用并查集，如何经常查询一个元素是否在
   某个集合或者带有某个标记，考虑使用st[]
   4. 在dfs中记录路径时， 一般用vector<int>放在.data
   5. vector还能作为栈使用
   
* 算法
设计程序，使得我们从一个初始状态，在有限时间内，不断逼近问题的解，逼近的速度
就是我们的算法效率
----------------------------------
这个状态可以是集合或者定义在集合上的函数：buttom-up(eg:dp), top-down(eg:bfs)
可以是数：二分，倍增
-----------------------------

* BFS
** 解决连通性问题（Flood-fill）
   1. 棋盘连通性
   2. 状态连通性
** 解决最短路模型问题--（抽象）--> 解决最小步数模型问题
** 树和图的遍历
** 变形与优化
   1. 双端队列广搜
   2. 双向广搜
   3. A star
* DFS
** 解决连通性问题
** 排列组合型遍历/枚举问题（利用dfs按照一定顺序进行遍历）
   本质上就是按一定顺序进行集合划分（分类）
   排列：位置1有n种选择，位置2有n-1种选择...，每一次选择对集合进行了一次划分
   组合：32位int数，选择5个位置置1，代表选择了这5个元素，从而所有这样的组合构成了组合数
** 树和图的遍历
** dfs状态转移处理
   1. 参数按值传递 dfs(int t), dfs(string s); 不用清理现场，浪费空间
   2. 全局变量，需要清理现场，节省空间
** 变形与优化
   1. 剪枝与优化
   2. 迭代加深
   3. 双向DFS
   4. IDA star
* 动态规划
** 解决多阶段决策过程的优化问题
把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解

在现实生活中，有一类活动的过程，由于其特殊性，可将过程分为若干个相互联系的阶段，
在它的每个阶段都需要作出决策，从而使整个过程达到最好的活动效果。

当然，各个阶段的决策的选取不是任意确定的，它依赖于当前面临的状态，又影响以后的发展，
当各个阶段决策确定以后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。
这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种
问题就成为多阶段决策问题。

动态规划问题不一定是多项式复杂度，可以是指数级，例如NP问题：哈密顿回路
一道题能否用动态规划求解只依赖于这道题能否划分阶段组成决策序列

动态规划的难点在于看出一道题如何能够通过动态规划的手段解决

我们通常能想到一种基础的枚举算法（dfs），然而难以想到动态规划的做法

** 解决递归算法中的“重叠子问题”(Fibnacci)


